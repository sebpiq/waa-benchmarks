;(function() {

var BLOCK_SIZE = null
var SAMPLE_RATE = null
var BYTES_PER_ELEMENT = 4
// Number of floats needed to store an osc
var OSC_LEN = 2


// A wrapper around the .js module generated by the wasm compiler.
function WasmDsp(wasmModule) {
  this._wasm_module = wasmModule
  
  this._oscList = null
  this._oscListPtr = null
  // Index of the last osc inserted in the list, add +1 to get the current number of oscs
  this._oscListInd = -1
  this._oscListLen = 0
  this._oscOutBlockPtr = this._wasm_module._malloc(BYTES_PER_ELEMENT * BLOCK_SIZE)
  this._wasm_oscSum = wasmModule.cwrap('sum_osc_static', null, ['number', 'number', 'number'])
}

WasmDsp.prototype.getOscCount = function() {
  return this._oscListInd + 1
}

WasmDsp.prototype.pushOsc = function(freq) {
  this._manageOscList(1)
  this._oscList[OSC_LEN * this._oscListInd] = 0 // phase
  this._oscList[OSC_LEN * this._oscListInd + 1] = 2 * Math.PI / SAMPLE_RATE * freq // K
}

WasmDsp.prototype.popOsc = function(freq) {
  this._manageOscList(-1)
}

WasmDsp.prototype._manageOscList = function(delta) {
  var realloc = false

  // Increase / decrease index
  this._oscListInd += delta
  this._oscListInd = Math.max(this._oscListInd, 0)

  // Allocate the initial osc list
  if (this._oscList === null) {
    realloc = true
    this._oscListLen = 100

  // If there are too many osc, we need to allocate more space
  } else if (this._oscListInd >= (this._oscListLen - 1)) {
    realloc = true
    this._oscListLen += 100
  }

  if (realloc) {
    // TODO : DEALLOC
    var bytesLength = this._oscListLen * 8 * OSC_LEN
    var ptr = this._wasm_module._malloc(bytesLength)
    var start = ptr / 8
    var newOscList = this._wasm_module.HEAPF64.subarray(start, start + this._oscListLen * OSC_LEN)
    if (this._oscList)
      newOscList.set(this._oscList)
    this._oscList = newOscList
    this._oscListPtr = ptr
  }
}

WasmDsp.prototype.computeNext = function() {
  this._wasm_oscSum(this._oscOutBlockPtr, this._oscListPtr, this.getOscCount())
  return this.getSubarray(this._oscOutBlockPtr, BLOCK_SIZE)
}

// Takes an Float32Array, copies it to the heap and returns a pointer
WasmDsp.prototype.arrayToPtr = function(array) {
  var ptr = this._wasm_module._malloc(array.length * BYTES_PER_ELEMENT)
  this._wasm_module.HEAPF32.set(array, ptr / BYTES_PER_ELEMENT)
  return ptr
}

// Takes a pointer and  array length, and returns a Float32Array from the heap
WasmDsp.prototype.ptrToArray = function(ptr, array) {
  var pos = ptr / BYTES_PER_ELEMENT
  array.set(this._wasm_module.HEAPF32.subarray(pos, pos + array.length))
  return array
}

// Takes a pointer and  array length, and returns a Float32Array from the heap
WasmDsp.prototype.getSubarray = function(ptr, length) {
  var pos = ptr / BYTES_PER_ELEMENT
  return this._wasm_module.HEAPF32.subarray(pos, pos + length)
}

function load(opts, done) {
  if (!opts.blockSize || !opts.sampleRate)
    throw new Error('missing initialization parameters')
  BLOCK_SIZE = opts.blockSize
  SAMPLE_RATE = opts.sampleRate

  var oReq = new XMLHttpRequest()
  oReq.responseType = 'arraybuffer'
  oReq.addEventListener('load', function reqListener () {
    // Loading wasm module
    var arrayBuffer = oReq.response
    var wasmDspModule = WasmDspModule({ wasmBinary: arrayBuffer })
    done(null, new WasmDsp(wasmDspModule))
  })
  oReq.open('GET', 'js/wasm_dsp_module.wasm')
  oReq.send()
}

this.wasmDsp = {
  load: load
}

}).apply(this)